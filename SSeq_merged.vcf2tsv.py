#!/usr/bin/env python3

# 1-based index in this program.

# This is meant to be a major improvement in features over the version described in the SomaticSeq paper published in Genome Biology. 
# Version 2.1

# Sample command:
# python3 SSeq_merged.vcf2tsv.py -myvcf BINA.snp.vcf -sniper somaticsniper/variants.vcf -varscan varscan2/variants.snp.vcf -jsm jointsnvmix2/variants.vcf -vardict vardict/variants.snp.vcf.gz -muse muse/variants.vcf -nbam normal.indelrealigned.bam -tbam tumor.indelrealigned.bam -ref human_g1k_v37_decoy.fasta -outfile SSeq2.snp.tsv

# For now, supports only tumor-normal workflows. Some metrics from individual VCF files generated by individual tools assume paired workflow. Future versions may be more flexible. 

# Improvement since the 2015 Genome Biology publication:
# Supports MuSE, LoFreq
# Allow +/- INDEL lengh for insertion and deletion
# Uses pysam to extract information directly from BAM files, e.g., flanking indel, edit distance, discordance, etc.
# Implement minimal mapping quality (MQ) and base call quality (BQ) for which pysam considers the reads in BAM files. 
# Allow user to count only non-duplicate reads if -dedup option is invoked. 

# -- 1/1/2016

import sys, argparse, math, gzip, os, pysam
import regex as re
import scipy.stats as stats
import genomic_file_handlers as genome
import pileup_reader as pileup
from read_info_extractor import * 

parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

input_sites = parser.add_mutually_exclusive_group()
input_sites.add_argument('-myvcf',  '--vcf-format',           type=str,   help='Input file is VCF formatted.', required=False, default=None)
input_sites.add_argument('-mybed',  '--bed-format',           type=str,   help='Input file is BED formatted.', required=False, default=None)
input_sites.add_argument('-mypos',  '--positions-list',       type=str,   help='A list of positions: tab seperating contig and positions.', required=False, default=None)

parser.add_argument('-nbam', '--normal-bam-file',             type=str,   help='Normal BAM File',    required=True, default=None)
parser.add_argument('-tbam', '--tumor-bam-file',              type=str,   help='Tumor BAM File',     required=True, default=None)

parser.add_argument('-truth',     '--ground-truth-vcf',       type=str,   help='VCF of true hits',  required=False, default=None)
parser.add_argument('-dbsnp',     '--dbsnp-vcf',              type=str,   help='dbSNP VCF: do not use if input VCF is annotated', required=False, default=None)
parser.add_argument('-cosmic',    '--cosmic-vcf',             type=str,   help='COSMIC VCF: do not use if input VCF is annotated',   required=False, default=None)

parser.add_argument('-mutect',  '--mutect-vcf',               type=str,   help='MuTect VCF',        required=False, default=None)
parser.add_argument('-sniper',  '--somaticsniper-vcf',        type=str,   help='SomaticSniper VCF', required=False, default=None)
parser.add_argument('-varscan', '--varscan-vcf',              type=str,   help='VarScan2 VCF',      required=False, default=None)
parser.add_argument('-jsm',     '--jsm-vcf',                  type=str,   help='JointSNVMix2 VCF',  required=False, default=None)
parser.add_argument('-vardict', '--vardict-vcf',              type=str,   help='VarDict VCF',       required=False, default=None)
parser.add_argument('-muse',    '--muse-vcf',                 type=str,   help='MuSE VCF',          required=False, default=None)
parser.add_argument('-lofreq',  '--lofreq-vcf',               type=str,   help='LoFreq VCF',        required=False, default=None)

parser.add_argument('-mincaller', '--minimum-num-callers',    type=float, help='Minimum number of tools to be considered', required=False, default=0)

parser.add_argument('-ref',     '--genome-reference',         type=str,   help='.fasta.fai file to get the contigs', required=True, default=None)

parser.add_argument('-minMQ',   '--minimum-mapping-quality',  type=float, help='Minimum mapping quality below which is considered poor', required=False, default=1)
parser.add_argument('-minBQ',   '--minimum-base-quality',     type=float, help='Minimum base quality below which is considered poor', required=False, default=5)
parser.add_argument('-dedup',   '--deduplicate',     action='store_true', help='Do not consider duplicate reads from BAM files. Default is to count everything', required=False, default=False)

parser.add_argument('-scale',      '--p-scale',               type=str,   help='phred, fraction, or none', required=False, default=None)
parser.add_argument('-samtools',   '--samtools-path',         type=str,   help='Path to samtools',required=False, default='samtools')

parser.add_argument('-outfile',    '--output-tsv-file',       type=str,   help='Output TSV Name', required=False, default=os.sys.stdout)

args = parser.parse_args()


# Rename input:
is_vcf    = args.vcf_format
is_bed    = args.bed_format
is_pos    = args.positions_list

nbam_fn   = args.normal_bam_file
tbam_fn   = args.tumor_bam_file

truehits  = args.ground_truth_vcf
cosmic    = args.cosmic_vcf
dbsnp     = args.dbsnp_vcf
mutect    = args.mutect_vcf
sniper    = args.somaticsniper_vcf
varscan   = args.varscan_vcf
jsm       = args.jsm_vcf
vardict   = args.vardict_vcf
muse      = args.muse_vcf
lofreq    = args.lofreq_vcf

min_mq    = args.minimum_mapping_quality
min_bq    = args.minimum_base_quality

ref_fa    = args.genome_reference
p_scale   = args.p_scale

outfile   = args.output_tsv_file

# Convert contig_sequence to chrom_seq dict:
fai_file  = ref_fa + '.fai'
chrom_seq = genome.faiordict2contigorder(fai_file, 'fai')

# Determine input format:
if is_vcf:
    mysites = is_vcf
elif is_bed:
    mysites = is_bed
elif is_pos:
    mysites = is_pos
else:
    mysites = fai_file
    print('No position supplied. Will evaluate the whole genome.', file=sys.stderr)

# Re-scale output or not:
if p_scale == None:
    print('NO RE-SCALING', file=sys.stderr)
elif p_scale.lower() == 'phred':
    p_scale = 'phred'
elif p_scale.lower() == 'fraction':
    p_scale = 'fraction'
else:
    p_scale = None
    print('NO RE-SCALING', file=sys.stderr)

def rescale(x, original=None, rescale_to=p_scale, max_phred=1001):
    if ( rescale_to == None ) or ( original.lower() == rescale_to.lower() ):
        y = x if isinstance(x, int) else '%.2f' % x
    elif original.lower() == 'fraction' and rescale_to == 'phred':
        y = genome.p2phred(x, max_phred=max_phred)
        y = '%.2f' % y
    elif original.lower() == 'phred' and rescale_to == 'fraction':
        y = genome.phred2p(x)
        y = '%.2f' % y
    return y
    

# Define NaN and Inf:
nan = float('nan')
inf = float('inf')
pattern_chr_position = genome.pattern_chr_position


# Normal/Tumor index in the Merged VCF file, or any other VCF file that puts NORMAL first. 
idxN,idxT = 0,1

# Normal/Tumor index in VarDict VCF, or any other VCF file that puts TUMOR first.
vdT,vdN = 0,1


# Header for the output data, created here so I won't have to indent this line:
out_header = \
'{CHROM}\t\
{POS}\t\
{ID}\t\
{REF}\t\
{ALT}\t\
{if_MuTect}\t\
{if_VarScan2}\t\
{if_JointSNVMix2}\t\
{if_SomaticSniper}\t\
{if_VarDict}\t\
{if_LoFreq}\t\
{MuSE_Tier}\t\
{VarScan2_Score}\t\
{SNVMix2_Score}\t\
{Sniper_Score}\t\
{VarDict_Score}\t\
{if_dbsnp}\t\
{COMMON}\t\
{if_COSMIC}\t\
{COSMIC_CNT}\t\
{N_DP}\t\
{nBAM_REF_MQ}\t\
{nBAM_ALT_MQ}\t\
{nBAM_Z_Ranksums_MQ}\t\
{nBAM_REF_BQ}\t\
{nBAM_ALT_BQ}\t\
{nBAM_Z_Ranksums_BQ}\t\
{nBAM_REF_NM}\t\
{nBAM_ALT_NM}\t\
{nBAM_NM_Diff}\t\
{nBAM_REF_Concordant}\t\
{nBAM_REF_Discordant}\t\
{nBAM_ALT_Concordant}\t\
{nBAM_ALT_Discordant}\t\
{nBAM_Concordance_FET}\t\
{N_REF_FOR}\t\
{N_REF_REV}\t\
{N_ALT_FOR}\t\
{N_ALT_REV}\t\
{nBAM_StrandBias_FET}\t\
{nBAM_Z_Ranksums_EndPos}\t\
{nBAM_REF_Clipped_Reads}\t\
{nBAM_ALT_Clipped_Reads}\t\
{nBAM_Clipping_FET}\t\
{nBAM_REF_MQ0}\t\
{nBAM_ALT_MQ0}\t\
{nBAM_Other_Reads}\t\
{nBAM_Poor_Reads}\t\
{nBAM_REF_InDel_3bp}\t\
{nBAM_REF_InDel_2bp}\t\
{nBAM_REF_InDel_1bp}\t\
{nBAM_ALT_InDel_3bp}\t\
{nBAM_ALT_InDel_2bp}\t\
{nBAM_ALT_InDel_1bp}\t\
{SOR}\t\
{MSI}\t\
{MSILEN}\t\
{SHIFT3}\t\
{MaxHomopolymer_Length}\t\
{SiteHomopolymer_Length}\t\
{T_DP}\t\
{tBAM_REF_MQ}\t\
{tBAM_ALT_MQ}\t\
{tBAM_Z_Ranksums_MQ}\t\
{tBAM_REF_BQ}\t\
{tBAM_ALT_BQ}\t\
{tBAM_Z_Ranksums_BQ}\t\
{tBAM_REF_NM}\t\
{tBAM_ALT_NM}\t\
{tBAM_NM_Diff}\t\
{tBAM_REF_Concordant}\t\
{tBAM_REF_Discordant}\t\
{tBAM_ALT_Concordant}\t\
{tBAM_ALT_Discordant}\t\
{tBAM_Concordance_FET}\t\
{T_REF_FOR}\t\
{T_REF_REV}\t\
{T_ALT_FOR}\t\
{T_ALT_REV}\t\
{tBAM_StrandBias_FET}\t\
{tBAM_Z_Ranksums_EndPos}\t\
{tBAM_REF_Clipped_Reads}\t\
{tBAM_ALT_Clipped_Reads}\t\
{tBAM_Clipping_FET}\t\
{tBAM_REF_MQ0}\t\
{tBAM_ALT_MQ0}\t\
{tBAM_Other_Reads}\t\
{tBAM_Poor_Reads}\t\
{tBAM_REF_InDel_3bp}\t\
{tBAM_REF_InDel_2bp}\t\
{tBAM_REF_InDel_1bp}\t\
{tBAM_ALT_InDel_3bp}\t\
{tBAM_ALT_InDel_2bp}\t\
{tBAM_ALT_InDel_1bp}\t\
{InDel_Length}\t\
{TrueVariant_or_False}'


## Running
with genome.open_textfile(mysites) as my_sites, open(outfile, 'w') as outhandle:
        
    my_line = my_sites.readline().rstrip()
    
    nbam    = pysam.AlignmentFile(nbam_fn)
    tbam    = pysam.AlignmentFile(tbam_fn)
    ref_fa  = pysam.FastaFile(ref_fa)
    
    if truehits:
        truth = genome.open_textfile(truehits)
        truth_line = truth.readline().rstrip()
        while truth_line.startswith('#'):
            truth_line = truth.readline().rstrip()
    
    if cosmic:
        cosmic = genome.open_textfile(cosmic)
        cosmic_line = cosmic.readline().rstrip()
        while cosmic_line.startswith('#'):
            cosmic_line = cosmic.readline().rstrip()

    if dbsnp:
        dbsnp = genome.open_textfile(dbsnp)
        dbsnp_line = dbsnp.readline().rstrip()
        while dbsnp_line.startswith('#'):
            dbsnp_line = dbsnp.readline().rstrip()
        
    if mutect:
        mutect = genome.open_textfile(mutect)
        mutect_line = mutect.readline().rstrip()
        while mutect_line.startswith('#'):
            mutect_line = mutect.readline().rstrip()
    
    if sniper:
        sniper = genome.open_textfile(sniper)
        sniper_line = sniper.readline().rstrip()
        while sniper_line.startswith('#'):
            sniper_line = sniper.readline().rstrip()
    
    if varscan:
        varscan = genome.open_textfile(varscan)
        varscan_line = varscan.readline().rstrip()
        while varscan_line.startswith('#'):
            varscan_line = varscan.readline().rstrip()
    
    if jsm:
        jsm = genome.open_textfile(jsm)
        jsm_line = jsm.readline().rstrip()
        while jsm_line.startswith('#'):
            jsm_line = jsm.readline().rstrip()
    
    if vardict:
        vardict = genome.open_textfile(vardict)
        vardict_line = vardict.readline().rstrip()
        while vardict_line.startswith('#'):
            vardict_line = vardict.readline().rstrip()
    
    if muse:
        muse = genome.open_textfile(muse)
        muse_line = muse.readline().rstrip()
        while muse_line.startswith('#'):
            muse_line = muse.readline().rstrip()
    
    if lofreq:
        lofreq = genome.open_textfile(lofreq)
        lofreq_line = lofreq.readline().rstrip()
        while lofreq_line.startswith('#'):
            lofreq_line = lofreq.readline().rstrip()
    
    
    # Get through all the headers:
    while my_line.startswith('#') or my_line.startswith('track='):
        my_line = my_sites.readline().rstrip()
    
    # First line:
    outhandle.write( out_header.replace('{','').replace('}','')  + '\n' )
    
    while my_line:
                
        if is_vcf:
            my_vcf = genome.Vcf_line( my_line )
            end_i = my_vcf.get_info_value('END')
            if end_i:
                end_i = int(end_i)
            else:
                end_i = my_vcf.position
            
            my_coordinates = genomic_coordinates(my_vcf.chromosome, my_vcf.position, end_i)            
        
        elif is_bed:
            bed_item = my_line.split('\t')
            my_coordinates = genomic_coordinates( bed_item[0], int(bed_item[1])+1, int(bed_item[2]) )
            
        elif is_pos:
            pos_item = my_line.split('\t')
            my_coordinates = genomic_coordinates( pos_item[0], int(pos_item[1]), int(pos_item[1]) )
            
        elif fai_file:
            fai_item = my_line.split('\t')
            my_coordinates = genomic_coordinates( fai_item[0], 1, int(fai_item[1]) )
        
        ##
        for my_coordinate in my_coordinates:
            
            my_identifiers = []
            
            ######## If VCF, can get ref base, variant base, as well as other identifying information ######## 
            if is_vcf:
                my_vcfcall = genome.Vcf_line( my_line )
                
                ref_base = my_vcfcall.refbase    
                first_alt = my_vcfcall.altbase.split(',')[0]
                indel_length = len(first_alt) - len(ref_base)
                
                for ID_i in my_vcfcall.identifier.split(','):
                    my_identifiers.append(ID_i)
                
                if_dbsnp  = 1 if re.search(r'rs[0-9]+', my_vcfcall.identifier) else 0
                if_cosmic = 1 if re.search(r'COS[MN][0-9]+', my_vcfcall.identifier) else 0
                if_common = 1 if my_vcfcall.get_info_value('COMMON') == '1' else 0
                num_cases = my_vcfcall.get_info_value('CNT') if my_vcfcall.get_info_value('CNT') else nan
                
            ## If not, 1) get ref_base, first_alt from other VCF files. 
            #          2) Create placeholders for dbSNP and COSMIC that can be overwritten with dbSNP/COSMIC VCF files (if provided)
            else:
                if_dbsnp = if_cosmic = if_common = num_cases = nan
                ref_base = first_alt = indel_length = None


            # Keep track of NumCallers:
            num_callers = 0
            
            ############################################################################################
            ######################## Find the same coordinate in MuTect's VCF #########################
            if args.mutect_vcf:
                
                latest_mutect_run = genome.catchup(my_coordinate, mutect_line, mutect, chrom_seq)
                latest_mutect = genome.Vcf_line(latest_mutect_run[1])
                
                if latest_mutect_run[0]:
                    
                    assert my_coordinate[1] == latest_mutect.position
                    mutect_classification = 1 if latest_mutect.get_info_value('SOMATIC') else 0

                    # If ref_base, first_alt, and indel_length unknown, get it here:
                    if not ref_base:         ref_base = latest_mutect.refbase
                    if not first_alt:        first_alt = latest_mutect.altbase.split('\t')
                    if indel_length == None: indel_length = len(first_alt) - len(ref_base)

                else:
                    mutect_classification = 0
                
                num_callers = num_callers + mutect_classification
                mutect_line = latest_mutect.vcf_line
                
            else:
                mutect_classification = nan


            ############################################################################################
            ##################### Find the same coordinate in VarDict's VCF Output #####################
            if args.vardict_vcf:
                latest_vardict_run = genome.catchup(my_coordinate, vardict_line, vardict, chrom_seq)
                latest_vardict = genome.Vcf_line(latest_vardict_run[1])
                
                if latest_vardict_run[0]:
                    assert my_vcfcall.position == latest_vardict.position
                    
                    if (latest_vardict.filters == 'PASS') and ('Somatic' in latest_vardict.info):
                        vardict_classification = 1
                    else:
                        vardict_filters = latest_vardict.filters.split(';')
                        
                        disqualifying_filters = ('d7' in vardict_filters or 'd5' in vardict_filters) or \
                        ('DIFF0.2' in vardict_filters) or \
                        ('LongAT' in vardict_filters) or \
                        ('MAF0.05' in vardict_filters) or \
                        ('MSI6' in vardict_filters) or \
                        ('NM4' in vardict_filters or 'NM4.25' in vardict_filters) or \
                        ('pSTD' in vardict_filters) or \
                        ('SN1.5' in vardict_filters) or \
                        ( 'P0.05' in vardict_filters and float(latest_vardict.get_info_value('SSF') ) >= 0.15 ) or \
                        ( ('v3' in vardict_filters or 'v4' in vardict_filters) and int(latest_vardict.get_sample_value('VD', 0))<3 )
                        
                        no_bad_filter = not disqualifying_filters
                        filter_fail_times = len(vardict_filters)
                        
                        if no_bad_filter and filter_fail_times<=2:
                            vardict_classification = 0.5
                        else:
                            vardict_classification = 0
                    
                    # Somatic Score:
                    score_vardict = latest_vardict.get_info_value('SSF')
                    if score_vardict:
                        score_vardict = float(score_vardict)
                        score_vardict = genome.p2phred(score_vardict, max_phred=100)
                    else:
                        score_vardict = nan

                    # SOR, MSI, MSILEN, and SHIFT3:
                    sor    = find_SOR(latest_vardict)
                    msi    = find_MSI(latest_vardict)
                    msilen = find_MSILEN(latest_vardict)
                    shift3 = find_SHIFT3(latest_vardict)                        
                    
                    # If ref_base, first_alt, and indel_length unknown, get it here:
                    if not ref_base:         ref_base = latest_mutect.refbase
                    if not first_alt:        first_alt = latest_mutect.altbase.split('\t')
                    if indel_length == None: indel_length = len(first_alt) - len(ref_base)
                                                                        
                # The VarDict.vcf doesn't have this record, which doesn't make sense. It means wrong file supplied. 
                else:
                    sor = msi = msilen = shift3 = score_vardict = nan
                    vardict_classification = 0
                
                num_callers = num_callers + vardict_classification
                vardict_line = latest_vardict.vcf_line
                    
            else:
                sor = msi = msilen = shift3 = score_vardict = nan
                vardict_classification = nan
            
            
            ############################################################################################
            ##################### Find the same coordinate in SomaticSniper's VCF# #####################
            if args.somaticsniper_vcf:
                
                latest_sniper_run = genome.catchup(my_coordinate, sniper_line, sniper, chrom_seq)
                latest_sniper = genome.Vcf_line(latest_sniper_run[1])
                
                if latest_sniper_run[0]:
                    
                    assert my_vcfcall.position == latest_sniper.position
                    
                    sniper_classification = 1 if latest_sniper.get_sample_value('SS', idxT) == '2' else 0
                    
                    # Somatic Score:
                    if sniper_classification == 1:
                        score_somaticsniper = latest_sniper.get_sample_value('SSC', idxT)
                        score_somaticsniper = int(score_somaticsniper) if score_somaticsniper else nan
                    else:
                        score_somaticsniper = nan

                    # If ref_base, first_alt, and indel_length unknown, get it here:
                    if not ref_base:         ref_base = latest_mutect.refbase
                    if not first_alt:        first_alt = latest_mutect.altbase.split('\t')
                    if indel_length == None: indel_length = len(first_alt) - len(ref_base)
                
                # The SomaticSniper.vcf doesn't have this record: 
                else:
                    score_somaticsniper = nan
                    sniper_classification = 0
                
                num_callers = num_callers + sniper_classification
                sniper_line = latest_sniper.vcf_line
                    
            else:
                score_somaticsniper = nan
                sniper_classification = nan
            
            
            ############################################################################################
            ######################## Find the same coordinate in VarScan's VCF #########################
            if args.varscan_vcf:
                
                latest_varscan_run = genome.catchup(my_coordinate, varscan_line, varscan, chrom_seq)
                latest_varscan = genome.Vcf_line(latest_varscan_run[1])
                
                if latest_varscan_run[0]:
                    
                    assert my_vcfcall.position == latest_varscan.position
                    
                    varscan_classification = 1 if latest_varscan.get_info_value('SOMATIC') else 0
                    score_varscan2 = int(latest_varscan.get_info_value('SSC'))
                
                    # If ref_base, first_alt, and indel_length unknown, get it here:
                    if not ref_base:         ref_base = latest_mutect.refbase
                    if not first_alt:        first_alt = latest_mutect.altbase.split('\t')
                    if indel_length == None: indel_length = len(first_alt) - len(ref_base)

                # The VarScan.vcf doesn't have this record. 
                else:
                    varscan_classification = 0
                    score_varscan2 = nan
                    
                num_callers = num_callers + varscan_classification
                varscan_line = latest_varscan.vcf_line
                    
            else:
                varscan_classification = nan
                score_varscan2 = nan
            
            
            ############################################################################################
            ########################## Find the same coordinate in JSM's VCF# ##########################
            if args.jsm_vcf:
                
                latest_jsm_run = genome.catchup(my_coordinate, jsm_line, jsm, chrom_seq)
                latest_jsm = genome.Vcf_line(latest_jsm_run[1])
                
                if latest_jsm_run[0]:
                    
                    assert my_vcfcall.position == latest_jsm.position
                    
                    jointsnvmix2_classification = 1
                    
                    # Somatic Score:
                    aaab = float( latest_jsm.get_info_value('AAAB') )
                    aabb = float( latest_jsm.get_info_value('AABB') )
                    jointsnvmix2_p = 1 - aaab - aabb
                    score_jointsnvmix2 = genome.p2phred(jointsnvmix2_p, max_phred=50)

                    # If ref_base, first_alt, and indel_length unknown, get it here:
                    if not ref_base:         ref_base = latest_mutect.refbase
                    if not first_alt:        first_alt = latest_mutect.altbase.split('\t')
                    if indel_length == None: indel_length = len(first_alt) - len(ref_base)
                    
                # Does't have this record. 
                else:
                    jointsnvmix2_classification = 0
                    score_jointsnvmix2 = nan
                
                num_callers = num_callers + jointsnvmix2_classification
                jsm_line = latest_jsm.vcf_line
                    
            else:
                jointsnvmix2_classification = nan
                score_jointsnvmix2 = nan
            
            
            ############################################################################################
            ########################## Find the same coordinate in MuSE's VCF# #########################
            if args.muse_vcf:
                
                latest_muse_run = genome.catchup(my_coordinate, muse_line, muse, chrom_seq)
                latest_muse = genome.Vcf_line(latest_muse_run[1])
                
                if latest_muse_run[0]:
                    
                    assert my_vcfcall.position == latest_muse.position
                    
                    # PASS and Tiers:
                    if latest_muse.filters   == 'PASS':
                        muse_classification = 1
                    elif latest_muse.filters == 'Tier1':
                        muse_classification = 0.9                        
                    elif latest_muse.filters == 'Tier2':
                        muse_classification = 0.8
                    elif latest_muse.filters == 'Tier3':
                        muse_classification = 0.7
                    elif latest_muse.filters == 'Tier4':
                        muse_classification = 0.6
                    elif latest_muse.filters == 'Tier5':
                        muse_classification = 0.5
                    else:
                        muse_classification = 0

                    # If ref_base, first_alt, and indel_length unknown, get it here:
                    if not ref_base:         ref_base = latest_mutect.refbase
                    if not first_alt:        first_alt = latest_mutect.altbase.split('\t')
                    if indel_length == None: indel_length = len(first_alt) - len(ref_base)
                
                # Does't have this record
                else:
                    muse_classification = 0
                
                num_callers = num_callers + muse_classification
                muse_line = latest_muse.vcf_line
                    
            else:
                muse_classification = nan
            
            
            ############################################################################################
            ######################## Find the same coordinate in LoFreq's VCF #########################
            if args.lofreq_vcf:
                
                latest_lofreq_run = genome.catchup(my_coordinate, lofreq_line, lofreq, chrom_seq)
                latest_lofreq = genome.Vcf_line(latest_lofreq_run[1])
                
                if latest_lofreq_run[0]:
                    
                    assert my_coordinate[1] == latest_lofreq.position
                    lofreq_classification = 1 if latest_lofreq.filters == 'PASS' else 0

                    # If ref_base, first_alt, and indel_length unknown, get it here:
                    if not ref_base:         ref_base = latest_mutect.refbase
                    if not first_alt:        first_alt = latest_mutect.altbase.split('\t')
                    if indel_length == None: indel_length = len(first_alt) - len(ref_base)
                            
                else:
                    lofreq_classification = 0
                
                num_callers = num_callers + lofreq_classification
                lofreq_line = latest_lofreq.vcf_line
                
            else:
                lofreq_classification = nan

            
            # Potentially write the output only if it meets this threshold:
            if num_callers >= args.minimum_num_callers:

                ########## Ground truth file ##########
                if args.ground_truth_vcf:
                                                
                    latest_truth_run = genome.catchup(my_coordinate, truth_line, truth, chrom_seq)
                    latest_truth = genome.Vcf_line(latest_truth_run[1])
                    
                    if latest_truth_run[0]:
                        
                        assert my_coordinate[1] == latest_truth.position
                        judgement = 1
                        my_identifiers.append('TruePositive')
                    
                    else:
                        judgement = 0
                        my_identifiers.append('FalsePositive')
                    
                    # Reset the current line:
                    truth_line = latest_truth.vcf_line
                    
                else:
                    judgement = nan
                

                ########## dbSNP ##########
                if args.dbsnp_vcf:
                                                
                    latest_dbsnp_run = genome.catchup(my_coordinate, dbsnp_line, dbsnp, chrom_seq)
                    latest_dbsnp = genome.Vcf_line(latest_dbsnp_run[1])
                    
                    if latest_dbsnp_run[0]:
                        
                        assert my_coordinate[1] == latest_dbsnp.position
                        
                        if_dbsnp = 1
                        if_common = 1 if latest_dbsnp.get_info_value('COMMON') == '1' else 0
                        
                        rsID = latest_dbsnp.identifier.split(',')
                        for ID_i in rsID:
                            my_identifiers.append( ID_i )
                    
                    else:
                        if_dbsnp = if_common = 0
                    
                    # Reset the current line:
                    dbsnp_line = latest_dbsnp.vcf_line
                                    
                
                ########## COSMIC ##########
                if args.cosmic_vcf:
                                                
                    latest_cosmic_run = genome.catchup(my_coordinate, cosmic_line, cosmic, chrom_seq)
                    latest_cosmic = genome.Vcf_line(latest_cosmic_run[1])
                    
                    if latest_cosmic_run[0]:
                        
                        assert my_coordinate[1] == latest_cosmic.position
                        
                        if_cosmic = 1
                        
                        num_cases = latest_cosmic.get_info_value('CNT')
                        if num_cases:
                            num_cases = num_cases
                        else:
                            num_cases = nan
                            
                        cosmicID = latest_cosmic.identifier.split(',')
                        for ID_i in cosmicID:
                            my_identifiers.append( ID_i )
                    
                    else:
                        if_cosmic = 0
                        num_cases = nan
                    
                    # Reset the current line:
                    cosmic_line = latest_cosmic.vcf_line


                ########## ######### ######### INFO EXTRACTION FROM BAM FILES ########## ######### #########
                # Normal BAM file:
                n_reads = nbam.fetch( my_coordinate[0], my_coordinate[1]-1, my_coordinate[1], multiple_iterators=False )

                n_ref_read_mq = n_alt_read_mq = n_ref_read_bq = n_alt_read_bq = []
                n_ref_edit_distance = n_alt_edit_distance = []
                n_ref_concordant_reads = n_alt_concordant_reads = n_ref_discordant_reads = n_alt_discordant_reads = 0
                n_ref_for = n_ref_rev = n_alt_for = n_alt_rev = N_dp = 0
                n_ref_SC_reads = n_alt_SC_reads = n_ref_notSC_reads = n_alt_notSC_reads = 0
                n_ref_MQ0 = n_alt_MQ0 = 0
                n_ref_pos_from_end = n_alt_pos_from_end = []
                n_ref_flanking_indel = n_alt_flanking_indel = []
                n_noise_read_count = n_poor_read_count  = 0
                
                for read_i in n_reads:
                    if not read_i.is_unmapped and dedup_test(read_i):
                        
                        N_dp += 1
                        
                        code_i, ith_base, base_call_i, indel_length_i, flanking_indel_i = position_of_aligned_read(read_i, my_vcfcall.position-1 )
                        
                        if read_i.mapping_quality < min_mq and mean(read_i.query_qualities) < min_bq:
                            n_poor_read_count += 1
                        
                        # Reference calls:
                        if code_i == 1 and base_call_i == my_vcfcall.refbase[0]:
                        
                            n_ref_read_mq.append( read_i.mapping_quality )
                            n_ref_read_bq.append( read_i.query_qualities[ith_base] )
                            
                            try:
                                n_ref_edit_distance.append( read_i.get_tag('NM') )
                            except KeyError:
                                pass
                            
                            # Concordance
                            if        read_i.is_proper_pair  and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                n_ref_concordant_reads += 1
                            elif (not read_i.is_proper_pair) and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                n_ref_discordant_reads += 1
                            
                            # Orientation
                            if (not read_i.is_reverse) and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                n_ref_for += 1
                            elif    read_i.is_reverse  and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                n_ref_rev += 1
                            
                            # Soft-clipped reads?
                            if read_i.cigar[0][0] == cigar_soft_clip or read_i.cigar[-1][0] == cigar_soft_clip:
                                n_ref_SC_reads += 1
                            else:
                                n_ref_notSC_reads += 1
                                
                            if read_i.mapping_quality == 0:
                                n_ref_MQ0 += 1
                                
                            # Distance from the end of the read:
                            if ith_base != None:
                                n_ref_pos_from_end.append( min(ith_base, read_i.query_length-ith_base) )
                                
                            # Flanking indels:
                            n_ref_flanking_indel.append( flanking_indel_i )

                        
                        # Alternate calls:
                        # SNV, or Deletion, or Insertion where I do not check for matching indel length
                        elif (indel_length == 0 and code_i == 1 and base_call_i == first_alt) or \
                             (indel_length < 0  and code_i == 2 and indel_length == indel_length_i) or \
                             (indel_length > 0  and code_i == 3):
                            
                            n_alt_read_mq.append( read_i.mapping_quality )
                            n_alt_read_bq.append( read_i.query_qualities[ith_base] )
                            
                            try:
                                n_alt_edit_distance.append( read_i.get_tag('NM') )
                            except KeyError:
                                pass
                            
                            # Concordance
                            if        read_i.is_proper_pair  and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                n_alt_concordant_reads += 1
                            elif (not read_i.is_proper_pair) and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                n_alt_discordant_reads += 1
                            
                            # Orientation
                            if (not read_i.is_reverse) and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                n_alt_for += 1
                            elif    read_i.is_reverse  and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                n_alt_rev += 1
                            
                            # Soft-clipped reads?
                            if read_i.cigar[0][0] == cigar_soft_clip or read_i.cigar[-1][0] == cigar_soft_clip:
                                n_alt_SC_reads += 1
                            else:
                                n_alt_notSC_reads += 1

                            if read_i.mapping_quality == 0:
                                n_alt_MQ0 += 1

                            # Distance from the end of the read:
                            if ith_base != None:
                                n_alt_pos_from_end.append( min(ith_base, read_i.query_length-ith_base) )
                                                    
                            # Flanking indels:
                            n_alt_flanking_indel.append( flanking_indel_i )
                        
                        
                        # Inconsistent read or 2nd alternate calls:
                        else:
                            n_noise_read_count += 1
                                
                # Done extracting info from tumor BAM. Now tally them:
                n_ref_mq        = mean(n_ref_read_mq)
                n_alt_mq        = mean(n_alt_read_mq)
                n_z_ranksums_mq = stats.ranksums(n_alt_read_mq, n_ref_read_mq)[0]
                
                n_ref_bq        = mean(n_ref_read_bq)
                n_alt_bq        = mean(n_alt_read_bq)
                n_z_ranksums_bq = stats.ranksums(n_alt_read_bq, n_ref_read_bq)[0]
                
                n_ref_NM        = mean(n_ref_edit_distance)
                n_alt_NM        = mean(n_alt_edit_distance)
                n_z_ranksums_NM = stats.ranksums(n_alt_edit_distance, n_ref_edit_distance)[0]
                n_NM_Diff       = n_alt_NM - n_ref_NM - abs(indel_length)
                
                n_concordance_fet = stats.fisher_exact(( (n_ref_concordant_reads, n_alt_concordant_reads), (n_ref_discordant_reads, n_alt_discordant_reads) ))[1]
                n_strandbias_fet  = stats.fisher_exact(( (n_ref_for, n_alt_for), (n_ref_rev, n_alt_rev) ))[1]
                n_clipping_fet    = stats.fisher_exact(( (n_ref_notSC_reads, n_alt_notSC_reads), (n_ref_SC_reads, n_alt_SC_reads) ))[1]
                
                n_z_ranksums_endpos = stats.ranksums(n_alt_pos_from_end, n_ref_pos_from_end)[0]
                
                n_ref_indel_3bp = n_ref_flanking_indel.count(3)
                n_ref_indel_2bp = n_ref_flanking_indel.count(2)
                n_ref_indel_1bp = n_ref_flanking_indel.count(1)
                n_alt_indel_3bp = n_alt_flanking_indel.count(3)
                n_alt_indel_2bp = n_alt_flanking_indel.count(2)
                n_alt_indel_1bp = n_alt_flanking_indel.count(1)
    
                
                ########################################################################################
                # Tumor BAM file:
                t_reads = tbam.fetch( my_coordinate[0], my_coordinate[1]-1, my_coordinate[1], multiple_iterators=False )
                
                t_ref_read_mq = t_alt_read_mq = t_ref_read_bq = t_alt_read_bq = []
                t_ref_edit_distance = t_alt_edit_distance = []
                t_ref_concordant_reads =t_alt_concordant_reads = t_ref_discordant_reads = t_alt_discordant_reads = 0
                t_ref_for = t_ref_rev = t_alt_for = t_alt_rev = T_dp = 0
                t_ref_SC_reads = t_alt_SC_reads = t_ref_notSC_reads = t_alt_notSC_reads = 0
                t_ref_MQ0 = t_alt_MQ0 = 0
                t_ref_pos_from_end = t_alt_pos_from_end = []
                t_ref_flanking_indel = t_alt_flanking_indel = []
                t_noise_read_count = t_poor_read_count  = 0
                
                for read_i in t_reads:
                    if not read_i.is_unmapped and dedup_test(read_i):
                        
                        T_dp += 1
                        
                        code_i, ith_base, base_call_i, indel_length_i, flanking_indel_i = position_of_aligned_read(read_i, my_vcfcall.position-1 )
                        
                        if read_i.mapping_quality < min_mq and mean(read_i.query_qualities) < min_bq:
                            t_poor_read_count += 1

                        # Reference calls:
                        if code_i == 1 and base_call_i == my_vcfcall.refbase[0]:
                        
                            t_ref_read_mq.append( read_i.mapping_quality )
                            t_ref_read_bq.append( read_i.query_qualities[ith_base] )
                            
                            try:
                                t_ref_edit_distance.append( read_i.get_tag('NM') )
                            except KeyError:
                                pass
                            
                            # Concordance
                            if        read_i.is_proper_pair  and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                t_ref_concordant_reads += 1
                            elif (not read_i.is_proper_pair) and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                t_ref_discordant_reads += 1
                            
                            # Orientation
                            if (not read_i.is_reverse) and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                t_ref_for += 1
                            elif    read_i.is_reverse  and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                t_ref_rev += 1
                            
                            # Soft-clipped reads?
                            if read_i.cigar[0][0] == cigar_soft_clip or read_i.cigar[-1][0] == cigar_soft_clip:
                                t_ref_SC_reads += 1
                            else:
                                t_ref_notSC_reads += 1

                            if read_i.mapping_quality == 0:
                                t_ref_MQ0 += 1
                                
                            # Distance from the end of the read:
                            if ith_base != None:
                                t_ref_pos_from_end.append( min(ith_base, read_i.query_length-ith_base) )
                                
                            # Flanking indels:
                            t_ref_flanking_indel.append( flanking_indel_i )

                        
                        # Alternate calls:
                        # SNV, or Deletion, or Insertion where I do not check for matching indel length
                        elif (indel_length == 0 and code_i == 1 and base_call_i == first_alt) or \
                             (indel_length < 0  and code_i == 2 and indel_length == indel_length_i) or \
                             (indel_length > 0  and code_i == 3):
                            
                            t_alt_read_mq.append( read_i.mapping_quality )
                            t_alt_read_bq.append( read_i.query_qualities[ith_base] )
                            
                            try:
                                t_alt_edit_distance.append( read_i.get_tag('NM') )
                            except KeyError:
                                pass
                            
                            # Concordance
                            if        read_i.is_proper_pair  and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                t_alt_concordant_reads += 1
                            elif (not read_i.is_proper_pair) and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                t_alt_discordant_reads += 1
                            
                            # Orientation
                            if (not read_i.is_reverse) and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                t_alt_for += 1
                            elif    read_i.is_reverse  and read_i.mapping_quality >= min_mq and read_i.query_qualities[ith_base] >= min_bq:
                                t_alt_rev += 1
                            
                            # Soft-clipped reads?
                            if read_i.cigar[0][0] == cigar_soft_clip or read_i.cigar[-1][0] == cigar_soft_clip:
                                t_alt_SC_reads += 1
                            else:
                                t_alt_notSC_reads += 1

                            if read_i.mapping_quality == 0:
                                t_alt_MQ0 += 1

                            # Distance from the end of the read:
                            if ith_base != None:
                                t_alt_pos_from_end.append( min(ith_base, read_i.query_length-ith_base) )
                                                    
                            # Flanking indels:
                            t_alt_flanking_indel.append( flanking_indel_i )
                        
                        
                        # Inconsistent read or 2nd alternate calls:
                        else:
                            t_noise_read_count += 1
                                
                
                # Done extracting info from tumor BAM. Now tally them:
                t_ref_mq        = mean(t_ref_read_mq)
                t_alt_mq        = mean(t_alt_read_mq)
                t_z_ranksums_mq = stats.ranksums(t_alt_read_mq, t_ref_read_mq)[0]
                
                t_ref_bq        = mean(t_ref_read_bq)
                t_alt_bq        = mean(t_alt_read_bq)
                t_z_ranksums_bq = stats.ranksums(t_alt_read_bq, t_ref_read_bq)[0]
                
                t_ref_NM        = mean(t_ref_edit_distance)
                t_alt_NM        = mean(t_alt_edit_distance)
                t_z_ranksums_NM = stats.ranksums(t_alt_edit_distance, t_ref_edit_distance)[0]
                t_NM_Diff       = t_alt_NM - t_ref_NM - abs(indel_length)
                
                t_concordance_fet = stats.fisher_exact(( (t_ref_concordant_reads, t_alt_concordant_reads), (t_ref_discordant_reads, t_alt_discordant_reads) ))[1]
                t_strandbias_fet  = stats.fisher_exact(( (t_ref_for, t_alt_for), (t_ref_rev, t_alt_rev) ))[1]
                t_clipping_fet    = stats.fisher_exact(( (t_ref_notSC_reads, t_alt_notSC_reads), (t_ref_SC_reads, t_alt_SC_reads) ))[1]
                
                t_z_ranksums_endpos = stats.ranksums(t_alt_pos_from_end, t_ref_pos_from_end)[0]
                
                t_ref_indel_3bp = t_ref_flanking_indel.count(3)
                t_ref_indel_2bp = t_ref_flanking_indel.count(2)
                t_ref_indel_1bp = t_ref_flanking_indel.count(1)
                t_alt_indel_3bp = t_alt_flanking_indel.count(3)
                t_alt_indel_2bp = t_alt_flanking_indel.count(2)
                t_alt_indel_1bp = t_alt_flanking_indel.count(1)
    
                ############################################################################################
                ############################################################################################
    
    
                # Homopolymer eval (Make sure to modify for INDEL):
                lseq  = ref_fa.fetch(my_coordinate[0], my_coordinate[1]-20, my_coordinate[1])
                rseq  = ref_fa.fetch(my_coordinate[0], my_coordinate[1]+1,  my_coordinate[1]+21)
                
                seq41_ref = lseq + ref_base  + rseq
                seq41_alt = lseq + first_alt + rseq
                
                ref_counts = genome.count_repeating_bases(seq41_ref)
                alt_counts = genome.count_repeating_bases(seq41_alt)
                
                homopolymer_length = max( max(ref_counts), max(alt_counts) )
                
                # Homopolymer spanning the variant site:
                ref_c = 0
                alt_c = 0
                for i in rseq:
                    if i == ref_base:
                        ref_c += 1
                    else:
                        break
                        
                for i in lseq[::-1]:
                    if i == ref_base:
                        ref_c += 1
                    else:
                        break
                
                for i in rseq:
                    if i == first_alt:
                        alt_c += 1
                    else:
                        break
                        
                for i in lseq[::-1]:
                    if i == first_alt:
                        alt_c += 1
                    else:
                        break
    
                site_homopolymer_length = max( alt_c+1, ref_c+1 )
    
                if my_identifiers:
                    my_identifiers = ','.join(my_identifiers)
                else:
                    my_identifiers = '.'

                # If VCF file was output, take the ALT. Otherwise, use "first_alt"
                my_alt = my_vcfcall.altbase if is_vcf else first_alt
                
                ###
                out_line = out_header.format( \
                CHROM                   = my_coordinate[0],                                       \
                POS                     = my_coordinate[1],                                       \
                ID                      = my_identifiers,                                         \
                REF                     = ref_base,                                               \
                ALT                     = my_alt,                                                 \
                if_MuTect               = mutect_classification,                                  \
                if_VarScan2             = varscan_classification,                                 \
                if_JointSNVMix2         = jointsnvmix2_classification,                            \
                if_SomaticSniper        = sniper_classification,                                  \
                if_VarDict              = vardict_classification,                                 \
                if_LoFreq               = lofreq_classification,                                  \
                MuSE_Tier               = muse_classification,                                    \
                VarScan2_Score          = rescale(score_varscan2,      'phred', p_scale, 1001),   \
                SNVMix2_Score           = rescale(score_jointsnvmix2,  'phred', p_scale, 1001),   \
                Sniper_Score            = rescale(score_somaticsniper, 'phred', p_scale, 1001),   \
                VarDict_Score           = rescale(score_vardict,       'phred', p_scale, 1001),   \
                if_dbsnp                = if_dbsnp,                                               \
                COMMON                  = if_common,                                              \
                if_COSMIC               = if_cosmic,                                              \
                COSMIC_CNT              = num_cases,                                              \
                N_DP                    = N_dp,                                                   \
                nBAM_REF_MQ             = '%g' % n_ref_mq,                                        \
                nBAM_ALT_MQ             = '%g' % n_alt_mq,                                        \
                nBAM_Z_Ranksums_MQ      = '%g' % n_z_ranksums_mq,                                 \
                nBAM_REF_BQ             = '%g' % n_ref_bq,                                        \
                nBAM_ALT_BQ             = '%g' % n_alt_bq,                                        \
                nBAM_Z_Ranksums_BQ      = '%g' % n_z_ranksums_bq,                                 \
                nBAM_REF_NM             = '%g' % n_ref_NM,                                        \
                nBAM_ALT_NM             = '%g' % n_alt_NM,                                        \
                nBAM_NM_Diff            = '%g' % n_NM_Diff,                                       \
                nBAM_REF_Concordant     = n_ref_concordant_reads,                                 \
                nBAM_REF_Discordant     = n_ref_discordant_reads,                                 \
                nBAM_ALT_Concordant     = n_alt_concordant_reads,                                 \
                nBAM_ALT_Discordant     = n_alt_discordant_reads,                                 \
                nBAM_Concordance_FET    = rescale(n_concordance_fet, 'fraction', p_scale, 1001),  \
                N_REF_FOR               = n_ref_for,                                              \
                N_REF_REV               = n_ref_rev,                                              \
                N_ALT_FOR               = n_alt_for,                                              \
                N_ALT_REV               = n_alt_rev,                                              \
                nBAM_StrandBias_FET     = rescale(n_strandbias_fet, 'fraction', p_scale, 1001),   \
                nBAM_Z_Ranksums_EndPos  = '%g' % n_z_ranksums_endpos,                             \
                nBAM_REF_Clipped_Reads  = n_ref_SC_reads,                                         \
                nBAM_ALT_Clipped_Reads  = n_alt_SC_reads,                                         \
                nBAM_Clipping_FET       = rescale(n_clipping_fet, 'fraction', p_scale, 1001),     \
                nBAM_REF_MQ0            = n_ref_MQ0,                                              \
                nBAM_ALT_MQ0            = n_alt_MQ0,                                              \
                nBAM_Other_Reads        = n_noise_read_count,                                     \
                nBAM_Poor_Reads         = n_poor_read_count,                                      \
                nBAM_REF_InDel_3bp      = n_ref_indel_3bp,                                        \
                nBAM_REF_InDel_2bp      = n_ref_indel_2bp,                                        \
                nBAM_REF_InDel_1bp      = n_ref_indel_1bp,                                        \
                nBAM_ALT_InDel_3bp      = n_alt_indel_3bp,                                        \
                nBAM_ALT_InDel_2bp      = n_alt_indel_2bp,                                        \
                nBAM_ALT_InDel_1bp      = n_alt_indel_1bp,                                        \
                SOR                     = sor,                                                    \
                MSI                     = msi,                                                    \
                MSILEN                  = msilen,                                                 \
                SHIFT3                  = shift3,                                                 \
                MaxHomopolymer_Length   = homopolymer_length,                                     \
                SiteHomopolymer_Length  = site_homopolymer_length,                                \
                T_DP                    = T_dp,                                                   \
                tBAM_REF_MQ             = '%g' % t_ref_mq,                                        \
                tBAM_ALT_MQ             = '%g' % t_alt_mq,                                        \
                tBAM_Z_Ranksums_MQ      = '%g' % t_z_ranksums_mq,                                 \
                tBAM_REF_BQ             = '%g' % t_ref_bq,                                        \
                tBAM_ALT_BQ             = '%g' % t_alt_bq,                                        \
                tBAM_Z_Ranksums_BQ      = '%g' % t_z_ranksums_bq,                                 \
                tBAM_REF_NM             = '%g' % t_ref_NM,                                        \
                tBAM_ALT_NM             = '%g' % t_alt_NM,                                        \
                tBAM_NM_Diff            = '%g' % t_NM_Diff,                                       \
                tBAM_REF_Concordant     = t_ref_concordant_reads,                                 \
                tBAM_REF_Discordant     = t_ref_discordant_reads,                                 \
                tBAM_ALT_Concordant     = t_alt_concordant_reads,                                 \
                tBAM_ALT_Discordant     = t_alt_discordant_reads,                                 \
                tBAM_Concordance_FET    = rescale(t_concordance_fet, 'fraction', p_scale, 1001),  \
                T_REF_FOR               = t_ref_for,                                              \
                T_REF_REV               = t_ref_rev,                                              \
                T_ALT_FOR               = t_alt_for,                                              \
                T_ALT_REV               = t_alt_rev,                                              \
                tBAM_StrandBias_FET     = rescale(t_strandbias_fet, 'fraction', p_scale, 1001),   \
                tBAM_Z_Ranksums_EndPos  = '%g' % t_z_ranksums_endpos,                             \
                tBAM_REF_Clipped_Reads  = t_ref_SC_reads,                                         \
                tBAM_ALT_Clipped_Reads  = t_alt_SC_reads,                                         \
                tBAM_Clipping_FET       = rescale(t_clipping_fet, 'fraction', p_scale, 1001),     \
                tBAM_REF_MQ0            = t_ref_MQ0,                                              \
                tBAM_ALT_MQ0            = t_alt_MQ0,                                              \
                tBAM_Other_Reads        = t_noise_read_count,                                     \
                tBAM_Poor_Reads         = t_poor_read_count,                                      \
                tBAM_REF_InDel_3bp      = t_ref_indel_3bp,                                        \
                tBAM_REF_InDel_2bp      = t_ref_indel_2bp,                                        \
                tBAM_REF_InDel_1bp      = t_ref_indel_1bp,                                        \
                tBAM_ALT_InDel_3bp      = t_alt_indel_3bp,                                        \
                tBAM_ALT_InDel_2bp      = t_alt_indel_2bp,                                        \
                tBAM_ALT_InDel_1bp      = t_alt_indel_1bp,                                        \
                InDel_Length            = indel_length,                                           \
                TrueVariant_or_False    = judgement )
                
                # Print it out to stdout:
                outhandle.write(out_line + '\n')
        
        # Read into the next line:
        my_line = my_sites.readline().rstrip()
        
    ##########  Close all open files if they were opened  ##########
    opened_files = (ref_fa, nbam, tbam, truth, cosmic, dbsnp, mutect, sniper, varscan, jsm, vardict, muse, lofreq)
    [opened_file.close() for opened_file in opened_files if opened_file]
